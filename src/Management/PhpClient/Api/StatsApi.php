<?php
/**
 * StatsApi
 * PHP version 5
 *
 * @category Class
 * @package  DoofinderManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Doofinder Management API
 *
 * # Introduction  Doofinder's management API allows you to perform some of the administrative tasks you can do on your search engines using the Doofinder control panel, directly from your code.  # Basics  ## Endpoint  All requests should be done via `https` to the right endpoint:  ``` https://{search-zone}-api.doofinder.com ```  Where `{search-zone}` is the code of the datacenter where your search engines are located.  For instance:  ``` https://eu1-api.doofinder.com https://us1-api.doofinder.com ```  ## Authentication  To authenticate you need a management API key. If you don't have one you can generate it in the Doofinder Admin by going to your Account and then to API Keys.  A valid API key looks like this:  ``` ab46030xza33960aac71a10248489b6c26172f07 ```  ### API Token  You can authenticate with the previous API key in header as a Token. The correct way to authenticate is to send a HTTP Header with the name `Authorization` and the value `Token {api-key}`  I.e.:  ``` Authorization: Token ab46030xza33960aac71a10248489b6c26172f07 ```  ### JWT Token (Draft)  If you prefer you can authenticate with a [JSON Web Token](https://jwt.io). The token must be signed with an API management key and there are some claims required in the JWT payload. These claims are:    * `iat` (issued at): Creation datetime timestamp, i.e. the moment when the JWT was created.    * `exp` (expiration time): Expiration datetime timestamp, i.e. the moment when the JWT is going to expire and will no longer be valid. The time span between issued and expiration dates must be shorter than a week.    * `name`: Your user code. It is your unique identifier as doofinder user. You can find this code in your profile page in the Doofinder's administration panel.  To authenticate using JWT you must send a HTTP header with the name `Authorization` and the value `Bearer {JWT-token}`.  I.e.:  ``` Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoidGVzdCIsImlhdCI6MTUxNjIzOTAyMn0.QX_3HF-T2-vlvzGDbAzZyc1Cd-J9qROSes3bxlgB4uk ```  ## Conventions  Along most of the code samples you will find placeholders for some common variable values. They are:    * `{hashid}`: The search engine's unique id. e.g.: d8fdeab7fce96a19d3fc7b0ca7a1e98b.    * `{index}`: When storing items, they're always stored under a certain _index_. e.g.: product.    * `{token}`: Your personal authentication token obtained in the control panel.    * `{uid}`: The unique identificator of a Doofinder User.  # Objects  ## Search Engines  A **search engine**:  - Consists of a set of indices and options to configure them. - Must contain at least one index. - Can be uniquely identified by a hash we call `hashid`. - Can be _processed_, which involves reading the data from the provided data sources (usually URLs), indexing the data in temporary indices and finally make the indices ready for use.  ## Indices  An **index**:  - Is a set of **data items** and options to describe those items, the description of the **data sources** to get them and the way they can be searched. - May have one (and only one) temporary index. A temporary index shares the same options of the main index. There are operations to manage temporary indices like create, delete, reindex, etc.  The usual flow for an index is to create a temporary index, index items on it and replace the main index with the temporary one.  This way you can reindex your whole data having zero downtime of the search service.  ## Data Sources  A **data source**:  - Defines the location for retrieving items for indexing and the most common is just a file URL. - Is accessed when the search engine is being processed.  An index does not need a data source if you index the items directly using the API.  ## Items  Items:  - Are the objects stored in an index. - Are returned as search results. - May have different schemas (collections of fields) depending on their index **preset** (if any). There are some default presets, being `product` the most usual, which describes items with a price, category, etc.
 *
 * OpenAPI spec version: 2.0
 * Contact: support@doofinder.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.18
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace DoofinderManagement\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use DoofinderManagement\ApiException;
use DoofinderManagement\Configuration;
use DoofinderManagement\HeaderSelector;
use DoofinderManagement\ObjectSerializer;

/**
 * StatsApi Class Doc Comment
 *
 * @category Class
 * @package  DoofinderManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StatsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bannersClicks
     *
     * Gets the total amount of clicks performed in banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsBannersResult
     */
    public function bannersClicks($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->bannersClicksWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation bannersClicksWithHttpInfo
     *
     * Gets the total amount of clicks performed in banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsBannersResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersClicksWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsBannersResult';
        $request = $this->bannersClicksRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsBannersResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersClicksAsync
     *
     * Gets the total amount of clicks performed in banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->bannersClicksAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersClicksAsyncWithHttpInfo
     *
     * Gets the total amount of clicks performed in banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsBannersResult';
        $request = $this->bannersClicksRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersClicks'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersClicksRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling bannersClicks'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling bannersClicks'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersClicks'
            );
        }

        $resourcePath = '/api/v2/stats/banners/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bannersDisplay
     *
     * Gets how many times a banner has been displayed.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsBannersResult
     */
    public function bannersDisplay($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->bannersDisplayWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation bannersDisplayWithHttpInfo
     *
     * Gets how many times a banner has been displayed.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsBannersResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersDisplayWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsBannersResult';
        $request = $this->bannersDisplayRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsBannersResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersDisplayAsync
     *
     * Gets how many times a banner has been displayed.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->bannersDisplayAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersDisplayAsyncWithHttpInfo
     *
     * Gets how many times a banner has been displayed.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsBannersResult';
        $request = $this->bannersDisplayRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersDisplay'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersDisplayRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling bannersDisplay'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling bannersDisplay'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersDisplay'
            );
        }

        $resourcePath = '/api/v2/stats/banners/displays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkoutsByDate
     *
     * Gets the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTimeResult
     */
    public function checkoutsByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->checkoutsByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation checkoutsByDateWithHttpInfo
     *
     * Gets the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkoutsByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->checkoutsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkoutsByDateAsync
     *
     * Gets the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        return $this->checkoutsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkoutsByDateAsyncWithHttpInfo
     *
     * Gets the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->checkoutsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkoutsByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkoutsByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling checkoutsByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling checkoutsByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling checkoutsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/checkouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByDate
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTimeResult
     */
    public function clicksByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        list($response) = $this->clicksByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);
        return $response;
    }

    /**
     * Operation clicksByDateWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->clicksByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByDateAsync
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        return $this->clicksByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByDateAsyncWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->clicksByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByDate'
            );
        }

        $resourcePath = '/api/v2/stats/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByQuery
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\InlineResponse200
     */
    public function clicksByQuery($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->clicksByQueryWithHttpInfo($from, $to, $hashid, $query, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation clicksByQueryWithHttpInfo
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByQueryWithHttpInfo($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\InlineResponse200';
        $request = $this->clicksByQueryRequest($from, $to, $hashid, $query, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByQueryAsync
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsync($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->clicksByQueryAsyncWithHttpInfo($from, $to, $hashid, $query, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByQueryAsyncWithHttpInfo
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsyncWithHttpInfo($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\InlineResponse200';
        $request = $this->clicksByQueryRequest($from, $to, $hashid, $query, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByQuery'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByQueryRequest($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksByQuery'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksByQuery'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByQuery'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling clicksByQuery'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/by-query/{query}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($query !== null) {
            $resourcePath = str_replace(
                '{' . 'query' . '}',
                ObjectSerializer::toPathValue($query),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksTop
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\InlineResponse2001
     */
    public function clicksTop($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        list($response) = $this->clicksTopWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query);
        return $response;
    }

    /**
     * Operation clicksTopWithHttpInfo
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksTopWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        $returnType = '\DoofinderManagement\Model\InlineResponse2001';
        $request = $this->clicksTopRequest($from, $to, $hashid, $tz, $device, $format, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksTopAsync
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        return $this->clicksTopAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksTopAsyncWithHttpInfo
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        $returnType = '\DoofinderManagement\Model\InlineResponse2001';
        $request = $this->clicksTopRequest($from, $to, $hashid, $tz, $device, $format, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksTop'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksTopRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksTop'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksTop'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksTop'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initsByDate
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTimeResult
     */
    public function initsByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->initsByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation initsByDateWithHttpInfo
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function initsByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->initsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initsByDateAsync
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        return $this->initsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initsByDateAsyncWithHttpInfo
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->initsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initsByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function initsByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling initsByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling initsByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling initsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/inits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redirects
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsRedirectsResult
     */
    public function redirects($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->redirectsWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation redirectsWithHttpInfo
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsRedirectsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function redirectsWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsRedirectsResult';
        $request = $this->redirectsRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsRedirectsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redirectsAsync
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->redirectsAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redirectsAsyncWithHttpInfo
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsRedirectsResult';
        $request = $this->redirectsRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redirects'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function redirectsRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling redirects'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling redirects'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling redirects'
            );
        }

        $resourcePath = '/api/v2/stats/redirects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByClick
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTopSearchesResult
     */
    public function searchesByClick($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->searchesByClickWithHttpInfo($from, $to, $hashid, $dfid, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation searchesByClickWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTopSearchesResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByClickWithHttpInfo($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTopSearchesResult';
        $request = $this->searchesByClickRequest($from, $to, $hashid, $dfid, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTopSearchesResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByClickAsync
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsync($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->searchesByClickAsyncWithHttpInfo($from, $to, $hashid, $dfid, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByClickAsyncWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsyncWithHttpInfo($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTopSearchesResult';
        $request = $this->searchesByClickRequest($from, $to, $hashid, $dfid, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByClick'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByClickRequest($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesByClick'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesByClick'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByClick'
            );
        }
        // verify the required parameter 'dfid' is set
        if ($dfid === null || (is_array($dfid) && count($dfid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dfid when calling searchesByClick'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/{dfid}/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($dfid !== null) {
            $resourcePath = str_replace(
                '{' . 'dfid' . '}',
                ObjectSerializer::toPathValue($dfid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByDate
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTimeResult
     */
    public function searchesByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        list($response) = $this->searchesByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);
        return $response;
    }

    /**
     * Operation searchesByDateWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->searchesByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByDateAsync
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        return $this->searchesByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByDateAsyncWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->searchesByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByDate'
            );
        }

        $resourcePath = '/api/v2/stats/searches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($source !== null) {
            $queryParams['source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesTop
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTopSearchesResult
     */
    public function searchesTop($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        list($response) = $this->searchesTopWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);
        return $response;
    }

    /**
     * Operation searchesTopWithHttpInfo
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTopSearchesResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesTopWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTopSearchesResult';
        $request = $this->searchesTopRequest($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTopSearchesResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesTopAsync
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        return $this->searchesTopAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesTopAsyncWithHttpInfo
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        $returnType = '\DoofinderManagement\Model\StatsTopSearchesResult';
        $request = $this->searchesTopRequest($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesTop'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Timezones may be specified as an ISO 8601 UTC offset. (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  \DoofinderManagement\Model\QueryName $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesTopRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesTop'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesTop'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesTop'
            );
        }

        $resourcePath = '/api/v2/stats/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usage
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DoofinderManagement\Model\StatsTimeResult
     */
    public function usage($from, $to, $hashid, $type = null, $format = 'json')
    {
        list($response) = $this->usageWithHttpInfo($from, $to, $hashid, $type, $format);
        return $response;
    }

    /**
     * Operation usageWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \DoofinderManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DoofinderManagement\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function usageWithHttpInfo($from, $to, $hashid, $type = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->usageRequest($from, $to, $hashid, $type, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DoofinderManagement\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usageAsync
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsync($from, $to, $hashid, $type = null, $format = 'json')
    {
        return $this->usageAsyncWithHttpInfo($from, $to, $hashid, $type, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usageAsyncWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsyncWithHttpInfo($from, $to, $hashid, $type = null, $format = 'json')
    {
        $returnType = '\DoofinderManagement\Model\StatsTimeResult';
        $request = $this->usageRequest($from, $to, $hashid, $type, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usage'
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  \DoofinderManagement\Model\Hashid $hashid Unique id of the search engine. Can be a list of ids in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usageRequest($from, $to, $hashid, $type = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling usage'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling usage'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling usage'
            );
        }

        $resourcePath = '/api/v2/stats/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
